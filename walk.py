"""Walk a directory for files with the specified extensions."""

import os
import os.path
import unittest

def _clean_extensions(extensions):
    """Remove whitespace and prepend a period to extensions."""
    result = []
    for extension in extensions:
        if not isinstance(extension, str):
            continue
        cleaned = extension.strip().lower()
        if cleaned.startswith('.'):
            result.append(cleaned)
        else:
            result.append('.' + cleaned)
    return result

def _has_query(path, query):
    """Return True if the file at path contains query."""
    if not isinstance(path, str):
        raise TypeError('path must be a valid string path to a file.')
    if not os.path.isfile(path):
        raise ValueError('path must be a valid string path to a file.')

    with open(path, 'r', encoding='utf-8') as f:
        source = f.read()
    return query in source

def _print_error(error):
    """Print the OSError generated by os.walk()."""
    print(error)

def _walk(path, accepted=('.html',), query=''):
    """Walk the directory at path and print files with extensions in accepted.

    Args:
        path: String path to a directory to walk.
        accepted: Iterable containing string lowercase extensions to accept.
            Defaults to ('.html',).
        query: String query to look for in matching files.
            Defaults to the empty string.
    """
    for parent, dirnames, filenames in os.walk(path, onerror=_print_error):
        for filename in filenames:
            name, extension = os.path.splitext(filename)
            # Filter for accepted extensions
            if extension.strip().lower() in accepted:
                path = os.path.join(parent, filename)
                if len(query) <= 0:
                    print(path)
                elif _has_query(path, query):
                    print(path)


class _UnitTest(unittest.TestCase):
    def test_clean_extensions(self):
        """Test cleaning the extensions."""
        for value in [None, 42]:
            self.assertRaises(TypeError, _clean_extensions, value)
        for value in [(), [], {}, [None, 42]]:
            self.assertEqual(_clean_extensions(value), [])
        for extension in ['html', 'py']:
            expected = ['.' + extension.lower()]
            for value in [extension.lower(),
                          extension.title(),
                          extension.upper()]:
                self.assertEqual(_clean_extensions([value]), expected)
                self.assertEqual(_clean_extensions([' ' + value]), expected)
                self.assertEqual(_clean_extensions([value + ' ']), expected)
                self.assertEqual(_clean_extensions([' ' + value + ' ']),
                                 expected)
                self.assertEqual(_clean_extensions(['.' + value]), expected)
        self.assertEqual(_clean_extensions(['HTML', 'py']), ['.html', '.py'])

    def test_has_query(self):
        """Test looking for a query in a file."""
        for value in [None, 42, []]:
            self.assertRaises(TypeError, _has_query, value, 'foobar')
        for value in ['', 'foobar', 'foobar.py']:
            self.assertRaises(ValueError, _has_query, value, 'foobar')
        self.assertFalse(_has_query('LICENSE', 'foobar'))
        self.assertTrue(_has_query('LICENSE', 'MIT'))

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-e', '--extensions', nargs='+', default=['.html'],
                        help='string extensions to accept')
    parser.add_argument('-q', '--query', default='',
                        help='string query to find')
    parser.add_argument('path', nargs='?', default='',
                        help='path to the directory to walk')
    args = parser.parse_args()

    if os.path.isdir(args.path):
        _walk(args.path, _clean_extensions(args.extensions), args.query)
    else:
        suite = unittest.defaultTestLoader.loadTestsFromTestCase(_UnitTest)
        unittest.TextTestRunner(verbosity=2).run(suite)
