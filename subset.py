"""Walk directory base and compare it against directory copy.

Confirm all the files in base can be found and are identical in copy but not
vice versa. Basically, it establishes base is a subset of copy.
For bidirectionality, reverse the arguments and run the comparison again.

File comparisons are done using a hash algorithm in hashlib.
"""

import hashlib
import os
import os.path
import unittest

_DEFAULT_HASH = 'sha256'
"""String name of the default hash algorithm in hashlib to use."""

# Set this larger than 2047 bytes so the Python GIL is released
_SIZE = 2048
"""Positive integer number of bytes to read from a file at a time."""

def checksum(path, name=_DEFAULT_HASH, size=_SIZE):
    """Return the string hexadecimal digest checksum of the file at path.

    Args:
        path: String path to the file.
        name: Optional string name of the hash algorithm in hashlib to use.
            Defaults to _DEFAULT_HASH.
        size: Optional positive int number of bytes to read from the file at
            a time. Defaults to _SIZE.
    Returns:
        String hexadecimal digest checksum of the file at path.
    """
    if not isinstance(path, str):
        raise TypeError('path must be a valid string path to a file.')
    if not os.path.isfile(path):
        raise ValueError('path must be a valid string path to a file.')
    if not isinstance(name, str):
        raise TypeError('name must be a string.')
    if not isinstance(size, int):
        raise TypeError('size must be a positive int > 1024.')
    if size <= 1024:
        raise ValueError('size must be a positive int > 1024.')

    name = name.strip().lower()
    m = hashlib.new(name)
    with open(path, 'rb') as f:
        while True:
            # read() returns '' once EOF is reached and else breaks the loop
            data = f.read(size)
            if len(data) > 0:
                m.update(data)
            else:
                break
    return m.hexdigest()

def break_apart(path):
    """Return a list of directories that make up path.

    Use os.path.split() so it is OS independent. The splitting stops when the
    tail portion of the split is empty. This indicates a slash in the path,
    which is the root. In the case of relative paths, the head becomes empty
    after the last split.

    Args:
        path: String path.
    Returns:
        List of string directories that make up path.
    """
    if (not isinstance(path, str)) or (len(path) <= 0):
        return []

    # Remove any trailing slash
    # os.path.basename() for '/foo/bar/' returns an empty string
    if len(os.path.basename(path)) <= 0:
        path = os.path.dirname(path)

    parts = []
    head = path
    # Empty head - hit the beginning of a relative path
    while len(head) > 0:
        head, tail = os.path.split(head)
        if len(tail) > 0:
            parts.append(tail)
        else:
            # Empty tail - hit the root/drive letter of an absolute path
            parts.append(head)
            break
    parts.reverse()
    return parts

def get_matching_path(path, base, replacement):
    """Return the equivalent path starting at replacement instead of base.

    For example,
    >>> get_matching_path('foo/baz', 'foo', 'bar')
    'bar/baz'
    >>> get_matching_path('/var/tmp/bar', '/var/tmp', '/mnt/foo')
    '/mnt/foo/bar'

    Args:
        path: String full path.
        base: String starting portion of path to replace.
        replacement: String new starting path.
    Returns:
        String equivalent path starting at replacement instead of base.
    """
    if not isinstance(path, str):
        raise TypeError('path must be a non-empty string starting with base.')
    if len(path) <= 0:
        raise ValueError('path must be a non-empty string starting with base.')
    if not path.startswith(base):
        raise ValueError('path must be a non-empty string starting with base.')

    path_parts = break_apart(path)
    base_parts = break_apart(base)
    length = len(base_parts)
    # Invariant: base_parts is the subset at front of path_parts to ignore
    assert(path_parts[:length] == base_parts)
    replacement_parts = break_apart(replacement)
    replacement_parts.extend(path_parts[length:])
    return os.path.join(*replacement_parts)

def _print_error(error):
    """Print the OSError generated by os.walk()."""
    print(error)

def walk_and_compare(base, copy, name=_DEFAULT_HASH, verbose=False):
    """Walk directory base and compare each file against directory copy.

    Args:
        base: String path to the base directory.
        copy: String path to the copy directory.
        name: Optional string name of the hash function in hashlib to use.
            Defaults to _DEFAULT_HASH.
        verbose: Optional boolean flag indicating whether to print the
            filenames as they are being compared. Defaults to False.
    """
    if not isinstance(base, str):
        raise TypeError('base must be a string path to a directory.')
    if not isinstance(copy, str):
        raise TypeError('copy must be a string path to a directory.')
    if not os.path.isdir(base):
        raise ValueError('base must be a string path to a directory.')
    if not os.path.isdir(copy):
        raise ValueError('copy must be a string path to a directory.')
    if not isinstance(name, str):
        raise TypeError('name must be a string.')
    name = name.strip().lower()
    filename_only = name == 'name'

    for path, dirnames, filenames in os.walk(base, onerror=_print_error):
        # Ignore dirnames because we only compare files
        copy_path = get_matching_path(path, base, copy)
##        print('path:', break_apart(path))
##        print('base:', break_apart(base))
##        print('copy:', break_apart(copy))
##        print(copy_path)

        checksums = {}
        if not filename_only:
            # Calculate checksums of the files in the current subdirectory
            for filename in filenames:
                checksums[filename] = checksum(
                    os.path.join(path, filename), name)
        for filename in filenames:
            path_in_base = os.path.join(path, filename)
            path_in_copy = os.path.join(copy_path, filename)
            if verbose:
                print('{0} vs {1}'.format(path_in_base, path_in_copy))

            if os.path.isfile(path_in_copy):
                if not filename_only:
                    copy_checksum = checksum(path_in_copy, name)
                    if (checksums[filename] != copy_checksum):
                        print('{0}: Files differ!'.format(path_in_base))
            else:
                print('{0} not found!'.format(path_in_copy))


class _UnitTest(unittest.TestCase):
    def test_checksum(self):
        """Test calculating the checksum for a file."""
        for value in [None, 42.0, []]:
            self.assertRaises(TypeError, checksum, value)
            self.assertRaises(TypeError, checksum, 'checksum.py', value)
            self.assertRaises(TypeError, checksum, 'checksum.py', size=value)
        for value in ['', 'foobar']:
            self.assertRaises(ValueError, checksum, value)
            self.assertRaises(ValueError, checksum, 'checksum.py', value)
            self.assertRaises(TypeError, checksum, 'checksum.py', size=value)
        for value in range(-1, 1025):
            self.assertRaises(ValueError, checksum, 'checksum.py', size=value)

    def test_break_apart(self):
        """Test the path is broken into component directories correctly."""
        for value in [None, 42, '', []]:
            self.assertEqual(break_apart(value), [])

        self.assertEqual(break_apart('foo'), ['foo'])
        self.assertEqual(break_apart('foo/'), ['foo'])
        self.assertEqual(break_apart('foo/bar'), ['foo', 'bar'])
        self.assertEqual(break_apart('foo/bar/'), ['foo', 'bar'])
        self.assertEqual(break_apart('foo/bar/baz'), ['foo', 'bar', 'baz'])
        self.assertEqual(break_apart('foo/bar/baz/'), ['foo', 'bar', 'baz'])
        self.assertEqual(break_apart('/mnt/foo/bar'),
                         ['/', 'mnt', 'foo', 'bar'])
        self.assertEqual(break_apart('/mnt/foo/bar/'),
                         ['/', 'mnt', 'foo', 'bar'])

    def test_get_matching_path(self):
        """Test the matching path is built correctly."""
        for value in [None, 42, []]:
            self.assertRaises(TypeError, get_matching_path, value, '', '')
        self.assertRaises(ValueError, get_matching_path, '', '', 'baz')
        self.assertRaises(ValueError, get_matching_path, '', 'bar', 'baz')
        self.assertRaises(ValueError, get_matching_path, 'foo', 'bar', 'baz')

        # Test relative paths
        expected = 'bar/baz'
        self.assertEqual(get_matching_path('foo/baz', 'foo', 'bar'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo', 'bar'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz', 'foo/', 'bar'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo/', 'bar'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz', 'foo', 'bar/'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo', 'bar/'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz', 'foo/', 'bar/'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo/', 'bar/'),
                         expected)

        # Test absolute paths
        expected = '/mnt/foo/bar'
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp', '/mnt/foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp', '/mnt/foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp/', '/mnt/foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp/', '/mnt/foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp', '/mnt/foo/'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp', '/mnt/foo/'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp/', '/mnt/foo/'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp/', '/mnt/foo/'),
            expected)

        # Test relative paths to absolute paths
        expected = '/mnt/baz'
        self.assertEqual(get_matching_path('foo/baz', 'foo', '/mnt'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo', '/mnt'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz', 'foo/', '/mnt'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo/', '/mnt'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz', 'foo', '/mnt/'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo', '/mnt/'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz', 'foo/', '/mnt/'),
                         expected)
        self.assertEqual(get_matching_path('foo/baz/', 'foo/', '/mnt/'),
                         expected)

        # Test absolute paths to relative paths
        expected = 'foo/bar'
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp', 'foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp', 'foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp/', 'foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp/', 'foo'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp', 'foo/'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp', 'foo/'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar', '/var/tmp/', 'foo/'),
            expected)
        self.assertEqual(
            get_matching_path('/var/tmp/bar/', '/var/tmp/', 'foo/'),
            expected)

    def test_walk_and_compare(self):
        """Test the guard clauses in walk_and_compare()."""
        for value in [None, 42.0, []]:
            self.assertRaises(TypeError, walk_and_compare, value, '.')
            self.assertRaises(TypeError, walk_and_compare, '.', value)
            self.assertRaises(TypeError, walk_and_compare, '.', '.', value)
        self.assertRaises(ValueError, walk_and_compare, 'subset.py', '.')
        self.assertRaises(ValueError, walk_and_compare, '.', 'subset.py')

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-a', '--algorithm', default=_DEFAULT_HASH,
                        help='string name of the hash algorithm to use')
    parser.add_argument('-f', '--filename', action='store_true',
                        help='only compare the filenames')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='verbose output')
    parser.add_argument('base', nargs='?', default='',
                        help='directory to walk')
    parser.add_argument('copy', nargs='?', default='',
                        help='directory to match against base')
    args = parser.parse_args()

    if os.path.isdir(args.base) and os.path.isdir(args.copy):
        name = args.algorithm
        if args.filename:
            name = 'name'
        walk_and_compare(args.base, args.copy, name, verbose=args.verbose)
    else:
        import doctest
        tests = [doctest.DocTestSuite(),
                 unittest.defaultTestLoader.loadTestsFromTestCase(_UnitTest)]
        unittest.TextTestRunner(verbosity=2).run(unittest.TestSuite(tests))
